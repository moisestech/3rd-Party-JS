# Identify Publishers

## **8.3.3 Identifying publishers**

Nearly every web service API requires some kind of unique identifying token or API key.
This key is usually submitted with API requests to identify the requesting application.

At a bare minimum, such keys are used to track an application’s API usage and make
sure it isn’t abusing the system. For instance, if an application is initiating far too many
HTTP requests to the API, the service can respond by throttling or even rejecting that
application’s requests while leaving other publishers unaffected.
In a traditional web service API model, where requests are made privately from a
web server to the API, the contents of this key are never made public. This changes
when you’re making requests from the browser; if you ask publishers to submit an API
key with each request, that key will be publicly visible on the publisher’s website. In

that case, the key could be appropriated by another party and used to make unauthor-
ized requests.

Here’s an example of a publisher calling the Stork.api function, and also passing
an apiKey with the request. Because this code is publicly visible on the publisher’s web
page, the token is easily stolen using simple inspection:
Stork.api('products/details',
{
id: 1337,
apiKey: 'fca023afee2d6f0d0668661d4e29b314'
},
function(response) { /_ ... _/ }
);
AUTHORIZED DOMAINS
To combat unauthorized API usage, client-side APIs often ask for a set of authorized
domains from which their API key is permitted to make requests. That way, even
though the API key is public, it can’t be used outside the publisher’s domain(s).
You’ve already learned one way to verify that a request originates from a given
domain—using the Referer HTTP header. When your web service API receives a
request with an accompanying API key, it checks the Referer header of the HTTP
request and validates it against the set of authorized domains already supplied by the
publisher. Here’s a partial server implementation of the Camera Stork API endpoint,
written in Python and Flask.

**Listing 8.11 Using the Referer header to validate the request's originating domain**

from Flask import make_response as response
from urlparse import urlparse
@app.route('/api/<endpoint>')
def api(endpoint=None):
domain = urlparse(request.headers['Referer']).hostname
api_key = request.args.get('apiKey')
if domain not in trusted_domains(api_key):
return response('Unauthorized domain: %s' % domain, 403)

# Domain is trusted, continue processing API request

This implementation should be straightforward. The helper function, trusted
\_domains, returns a list of domains that corresponds with the provided API key. If the

referring domain isn’t found in that list, the server returns an error response with a
403 HTTP status code (Forbidden).
TUNNEL FILES AND THE REFERER HEADER
Not so fast. The solution demonstrated in listing 8.11 suffers from a critical flaw—
the web service API wrapper you implemented is actually issuing XmlHttpRequest
from Camera Stork’s domain (camerastork.com), and not the publisher’s. That
means that the Referer header sent to the API server will actually be the URL of your

tunnel.html file. This is one caveat of using a tunnel file: all the requests now origi-
nate from your domain.

Additionally, the Referer header itself can’t always be counted on. There are a
number of situations in which the browser doesn’t send Referer headers. For starters,
it’s possible for the user to simply disable sending the Referer header—which is
sometimes done for privacy reasons. The browser also drops the Referer header if a
request is made from an HTTPS resource (such as https://publisher.com) to a regular
HTTP resource (http://camerastork.com/api).
REFERER OR REFERRER? You’ve probably noticed that the Referer header

only has one R, when the word referrer has two. The misspelled word was incor-
porated into the HTTP specification accidentally, and remains the same today:

http://en.wikipedia.org/wiki/HTTP_referrer#Origin_of_the_term_referer.
Given these issues, we’ll look at an alternative solution that avoids the Referer header
entirely. First, you need to know the URL/domain of the document that loaded your
SDK. You could just write JavaScript code—executing in the parent context—to query
the current URL via window.location.href and pass that into the tunnel. But that’s
not safe, because a malicious publisher could pass an arbitrary value into the tunnel
themselves.
There’s an alternative (and safe) way of getting the parent document URL—using

window.postMessage’s Origin parameter. If you recall, every message sent via post-
Message contains an Origin parameter, which is the protocol, domain, and port of the

sender document (protocol://domain:port). This Origin value is generated by the
browser, and is present even in situations where the Referer header isn’t (say, if the
browser has Referer headers disabled).
You’ll extract this Origin value from inside your iframe and pass it to your server
with every XmlHttpRequest. To keep this value separate from normal API parameters
(and for other reasons we’ll get to in a moment), you’ll pass it as a custom HTTP
header. You’ll name this header CameraStork-Publisher-Origin. The CameraStork
prefix here is to avoid colliding with other, legitimate HTTP headers.
CUSTOM HTTP HEADERS AND THE X-_ PREFIX For years, application developers
used the X-_ prefix in custom headers to avoid collisions with standard
header names. As of June 2012, the IETF (Internet Engineering Task Force)
officially recommends against the use of the X- prefix (http://tools.ietf.org/
html/rfc6648). We still think there’s value in “namespacing” HTTP headers,

though, so we advocate prefixing with your organization’s name instead (for
example, CameraStork-\*).

Because the easyXDM RPC object wraps window.postMessage (and other fallback pro-
tocols), it makes the Origin value available as a property on the RPC instance.4

The
next listing is an amended version of the apiTunnel function inside tunnel.html,
which sends the parent Origin via the CameraStork-Publisher-Origin header.

**Listing 8.12 Using a custom header to pass the URL to the server**

function apiTunnel(endpoint, params, callback) {
function complete(xhr) { /_ ... _/ }
var options = {
url: 'http://camerastork.com/api/' + endpoint,
data: params,
method: 'GET',
complete: complete,
headers: {
'CameraStork-Publisher-Origin': rpc.origin
}
};
jQuery.ajax(options);
}
Now, on the server end, you’ll need to validate the CameraStork-Publisher-Origin
header. Let’s revisit the server API endpoint code—now in its final incarnation.

**Listing 8.13 Validating CameraStork-Publisher-Origin on the server**

@app.route('/api/<endpoint>')
def api(endpoint=None):
publisher_origin = request.headers['CameraStork-Publisher-Origin']
domain = urlparse(publisher_origin).hostname
api_key = request.args.get('apiKey')
if domain in trusted_domains(api_key):
return api_request()
else:
return make_response('Unauthorized domain: %s' % domain, 403)

# Continue processing request

Pat yourself on the back. Your SDK now properly validates that API requests match the
set of trusted domains specified by your publisher. As long as you can trust the value of
CameraStork-Publisher-Origin, that is.

FORGED HEADERS AND UNAUTHORIZED ACCESS
The implementation in listing 8.13 relies on the CameraStork-Publisher-Origin
header to accurately report the URL of the page using your SDK. But what if a rogue
website manages to spoof that header? They could use another publisher’s key and

make requests to your web service API under that publisher’s identity. So what’s stop-
ping them?

Spoofing a custom header is difficult. It turns out that it’s only possible to specify
custom headers using XmlHttpRequest. All other means of issuing requests—like
HTML forms, script tags, and Image objects—are incapable of setting headers. And
since the same-origin policy ensures that it’s only possible to use XmlHttpRequest

from a document on the same domain, a publisher is incapable of using XmlHttp-
Request from their page to make a request to your API. In other words, custom head-
ers should be safe.

At least, that’s what should happen. But as we hinted at earlier, the browser is made

up of many components, and not all of them adhere to the strict rules of the same-
origin policy. For example, there’s a known exploit in the popular Adobe Flash plugin

that makes it possible for a malicious web page to issue an XSRF request through Flash
while also setting arbitrary headers (http://mng.bz/Ka5x).

This means that custom headers alone aren’t enough to ensure that CameraStork-
Publisher-Origin hasn’t been tampered with by a publisher. You need to verify that

the request to your API originates from your tunnel file, and not an untrusted party.
The solution to this problem, as you learned in chapter 7, is XSRF tokens. By
embedding an XSRF token in your tunnel file and submitting that token again with

subsequent requests to your API, you can verify that the value of CameraStork-
Publisher-Origin hasn’t been tampered with. We’ll leave this as an exercise for you

to implement.
YOUR WEB SERVICE API IS STILL VULNERABLE TO ROGUE CLIENTS
It’s important to understand that these countermeasures only prevent a rogue website
from issuing HTTP requests under the identity of a regular browser user. It’s still possible
for determined parties to make unauthorized requests to your API.
For example, nothing can prevent an attacker from taking a publisher’s key and
issuing an HTTP request to your API using a nonbrowser client (a script written in any
programming language). To get around your XSRF protection, they can request the
tunnel file first and extract the XSRF token to submit with their malicious API request.
Or to get even more creative, a malicious user could build a custom version of
Chromium or Firefox that ignores same-origin policy checks. Then there’s nothing
stopping that user from opening up the console and issuing an XMLHttpRequest to
your web service API with fraudulent credentials.5

5 As far-fetched as this seems, our technical reviewer, Alex Sexton, has actually done this, and frankly, it
terrifies us.

But that doesn’t mean that Origin checking is a bad idea. What these countermea-
sures do is prevent a web publisher (loading your SDK) from posing as another pub-
lisher, because they can’t forge this header used by regular visitors to their website. In

other words, although you can’t stop a malicious client, you can stop a malicious
website. Afterward, your API will have to rely on reactionary server-side measures like IP
blocking or rate limiting to deal with individual abusers.

---

#### From [[_3_wrapping-apis]]

[//begin]: # "Autogenerated link references for markdown compatibility"
[_3_wrapping-apis]: _3_wrapping-apis "Wraping APIs"
[//end]: # "Autogenerated link references"
