# Asynchrous Loading

## **8.1.2 Async load**

So far, publishers can load your SDK using a standard, blocking script include. But blocking scripts, even minimal ones, are still bad. We’ll quickly look at a few techniques you can use to allow publishers to load your SDK asynchronously.

What’s tricky about loading an SDK asynchronously is that the publisher can’t execute the library’s functions until it is fully downloaded and parsed. If they do, they’ll get an error—the code isn’t ready yet. You didn’t have this problem earlier with your original widget implementation because that version executed automatically when it was ready. To solve this, you’ll need to give the publisher a code snippet that both loads the SDK library (sdk.js) asynchronously, and provides a means for the publisher to execute code when the file is ready.

Let’s first look at a simple—but naive—approach. You begin by providing publishers with an asynchronous script include snippet that loads sdk.js by creating a `<script>` DOM element and appending it to the publisher’s page. This snippet also binds an event handler to the <script> element’s load and readystatechange events; the handler fires when the script becomes loaded. In your documentation (or the snippet’s source code), you instruct publishers to input their code inside this event handler. When the handler fires, it means sdk.js has been loaded, and the publisher can safely call Stork.init.

**Listing 8.2 Publisher code for asynchronous loading is complex and error-prone.**

```html
<script>
  (function () {
    var script = document.createElement("script");
    script.async = true;
    script.src = "http://camerastork.com/sdk.js";
    script.load = script.onreadystatechange = function () {
      var rdyState = script.readyState;
      if (!rdyState || /loaded|complete/.test(rdyState)) {
        Stork.init(function () {
          Stork.productWidget({
            id: "1337",
            dom: "stork-widget-location",
          });
        });
        script.onload = null;
        script.onreadystatechange = null;
      }
    };
    var entry = document.getElementsByTagName("script")[0];
    entry.parentNode.insertBefore(script, entry);
  })();
</script>
```

Perhaps now you see why a junior programmer might stick to blocking script includes; this example is significantly more code than the blocking example from section 8.1.2. And although the publisher would ideally copy and paste most of this snippet from your SDK’s documentation into their source code, they still have to insert their own code in the middle of it, which could result in them accidentally modifying the wrong code. Minimizing the possibility of errors is a big deal; having to debug code for publishers is a huge time sink, and should be avoided. For these reasons, we don’t recommend using this solution.

**PREDEFINED CALLBACKS**
Obviously, dealing with script event handlers is somewhat intimidating—ideally you should hide these details from publishers. A better approach is to let publishers define a global callback function that’s invoked by your SDK after the initial script file loads. This callback will need to be declared as a specific, expected global variable, so that the SDK knows where to locate it. Ideally this variable is documented in your SDK documentation.

Let’s suppose that you’ve documented such a callback function, Stork_ready. The publisher will have to declare this function globally on their window object, with the expectation it’ll be fired when sdk.js has finished loading. The publisher script include snippet will thus look like the following listing.

---

#### From [[_1_sdk-implementation]]

[//begin]: # "Autogenerated link references for markdown compatibility"
[_1_sdk-implementation]: _1_sdk-implementation "SDK Implementation"
[//end]: # "Autogenerated link references"
