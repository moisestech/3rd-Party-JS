# URL Versioning

## **8.2.1 URL versioning**

Commonly, versioning is done via the SDK’s script URL. For this technique, you embed
a unique version string in your script URL. For example, the Camera Stork SDK could
be loaded using the following script URL:

<script src="http://camerastork.com/sdk_1.0.js"></script>

Here the version number, 1.0, is embedded in the script filename. If you decide to
introduce breaking changes to your SDK, you can create a new version of your SDK
and introduce the breaking changes there. For example, in order to safely introduce
the breaking changes to Stork.productWidget we discussed earlier, you’d make a
copy of sdk_1.0.js, name it sdk_1.1.js, and apply the changes there:

<script src="http://camerastork.com/sdk_1.1.js"></script>

The older file, sdk_1.0.js, doesn’t contain the changes, so anyone using that version
will be unaffected.
This technique is simple but effective. There’s just one major issue: what happens
when there are two script includes to your SDK on the same page, with each pointing
to a different version? This scenario is uncommon, but could occur if there are two
developers writing separate integrations on the same publisher property, or if another
third-party script used by the publisher was trying to communicate with the Camera
Stork SDK.

Let’s see how this scenario is currently handled in the SDK. If you recall the SDK
architecture from earlier, the top of sdk.js contained the following code:
(function(window, undefined) {
var Stork = {};
if (window.Stork) {
return;
}
...
})(this);
You’ll notice that if the Stork object is already defined, the script exits early. This
means that any subsequent declaration of sdk.js won’t actually do anything. This
wasn’t an issue when there was only one version of the application, because the code
would only be replacing itself with an identical version. But with multiple versions, this
code prevents anyone from loading two distinct versions on the same page.
VERSIONS DON’T HAVE TO BE NUMERIC As with all software, you have other
options for version strings besides numbers. You can use symbolic names like
latest to always serve the latest version of your SDK, or dev to serve the latest
bleeding-edge development version.
Here’s an example depicting this scenario, where the Camera Stork SDK is loaded
twice, each pointing to a different file/version:

<script src="http://camerastork.com/sdk_1.0.js"></script>
<script>
/* Version 1.0 loaded */
</script>
<script src="http://camerastork.com/sdk_1.1.js"></script>
<script>
/* Version 1.0 is still loaded */
</script>

To solve this, your first instinct might be to modify sdk.js such that any subsequent
loads of the SDK replace the earlier version (if it exists). But then you’ll have the
opposite problem: any long-running code on this page that expects version 1.0 of the
SDK will now be incompatible with the newly loaded version (1.1).
IMPLEMENTING NOCONFLICT
Luckily, this situation is resolvable. If you remember, all the way back in chapter 2 we
showed you how to load the jQuery JavaScript library in a context where it might’ve
already been loaded by the publisher. In order to avoid conflicting with the parent
page, you called jQuery’s $.noConflict function. This function assigns the last-loaded
global jQuery to a local variable, ensuring that you only use the version you want:
Stork.jQuery = jQuery.noConflict(true);

Now, the noConflict function isn’t solely a jQuery thing—it’s a pattern that’s imple-
mented in a number of notable JavaScript libraries, including Backbone.js, Under-
score.js, and easyXDM, to name a few. We’ll add the Camera Stork SDK to that list of

libraries.
To do that, let’s return to sdk.js (listing 8.5). First, you’ll remove the line that exits
early if a global Stork object already exists. Instead, you’ll cache the existing Stork
object before overwriting it with the new version. If Stork.noConflict is called, it’ll
restore the cached object to its original location.

**Listing 8.5 Implementing noConflict for the Camera Stork SDK**

```javascript
(function(window, undefined) {
var Stork = {};
...
var \_Stork = window.Stork;
window.Stork = Stork;
Stork.noConflict = function() {
window.Stork = \_Stork;
return Stork;
};
})(this);
```

Pretty easy, eh? Now a publisher only has to write the following code to ensure that
they only reference the correct version of the SDK:

<script src="http://camerastork.com/sdk_1.0.js"></script>
<script>
window.MyStork = Stork.noConflict();
</script>

Now, even if someone comes along and loads a different version, window.MyStork will
remain untouched. Success!

---

### From [[_2_versioning]]

[//begin]: # "Autogenerated link references for markdown compatibility"
[_2_versioning]: _2_versioning "Versioning"
[//end]: # "Autogenerated link references"
