# Fetching App Data

## **2.6 Fetching Application Data**

By this point, you’ve distributed a script include snippet to participating publishers,

who’ve included it in their pages’ HTML source code. That snippet loads your applica-
tion code, which then loads any supporting files of its own. Your application then

extracts any parameters that were included as part of the script include snippet. For
the Camera Stork example, this is a single parameter, product ID, which is used to
identify the product to be rendered.

That’s a lot of progress for one chapter, but we’ve hit a snag. Before you can ren-
der that product, you need to first retrieve information about it from the server—

information like the product’s name, price, appearance, and current rating.
There are two approaches to solving this. The first (and easiest) approach is to
embed the entire Camera Stork product catalog as a JavaScript object inside your
application’s source code. This could be included in your main widget file (widget.js),
but because the catalog is perhaps likely to change (prices change daily), it might be
better loaded as a separate JavaScript file using the techniques we showed you in
section 2.4.
Here’s how the catalog object might be declared, in a separate source file
(catalog.js):

```javascript
Stork.catalog = (function() {
return {
1337: { name: 'E90', company: 'Mikon', price: '599.99' },
1338: { name: 'FabPix 30', company: 'Mikon', price: '139.99' },
...
8871: { name: 'SuperShot', company: 'Kanon', price: '178.99' },
8872: { name: 'SuperShot', company: 'Kanon', price: '219.99' }
};
})();
```

Presuming that this file is loaded earlier inside the loadSupportingFiles function,
the getProductData function should look like the following:

```javascript
function getProductData(params, callback) {
  var id = params.id;
  callback(Stork.catalog[id]);
}
```

Not difficult, but not exactly best practice either. What happens if the Camera Stork
product catalog is particularly large? It’s not unreasonable to suggest that a camera
store’s entire catalog might include tens of thousands of items. If each product entry
takes roughly 100 bytes to describe, that would mean having to serve a JavaScript file
that weighs nearly a megabyte (100 bytes x 10,000 = just under 1 MB). That might fly in
the high-bandwidth tomorrow-cities of Tokyo and Seoul, but for the rest of the world,
that’s an overwhelming amount of data to download.

The alternative (and second approach) is to fetch the product information indi-
vidually from the server. This is why getProductData accepted a callback parameter

to begin with—it presumes that to fetch the data, you’ll need to initiate an HTTP
request to the server for the given product ID and wait for a response before firing
the callback.
For a normal web application, this is easily solved using XmlHttpRequest, or as it’s
commonly referred to today, AJAX. But as we briefly mentioned in chapter 1, and for
reasons we’ll explain later in this book, the browser restricts XmlHttpRequest to the
same domain, which means you can’t make an AJAX call from the publisher’s website
to your own servers.

Dynamically requesting data from the server (or submitting data to the server) is
an advanced subject, and one we’ll get into shortly in chapter 4. For now, let’s stick
with the naive approach of embedding the entire Camera Stork catalog inside the
application code.

---

#### From [[_dist-loading]]

[//begin]: # "Autogenerated link references for markdown compatibility"
[_dist-loading]: ../_dist-loading "2️⃣ Dist & Loading"
[//end]: # "Autogenerated link references"
