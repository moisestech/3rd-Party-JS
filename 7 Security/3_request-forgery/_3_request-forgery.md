# Request Forgery

## **7.3 Cross-site Request Forgery**

In chapter 4, we talked about the same-origin policy. If you recall, this policy is implemented in all browsers and prevents web pages with different origins from accessing each other’s methods and properties. You’ve already learned a few tricks that you can use to send messages to your servers across the domain barrier. In this section, you’ll learn how this peculiarity can be turned against you.

Cross-site request forgery (CSRF or XSRF) is another type of vulnerability that targets your users.

Unlike XSS, which presents spoofed content to the user, XSRF exploits the trust that your web application has with a user’s browser. Essentially, XSRF-vulnerable web applications allow the attacker to perform unintended actions under the identity of users from the attacker’s own, often innocuous-looking, website.

In this section, we’ll first look at some canonical XSRF attack examples, and then look at JSON hijacking, a variation of the same vulnerability. Afterward, we’ll discuss strategies for defending against XSRF attacks. Let’s start by diving straight into some examples.

## **Sub-Chapters**

- [[3-1_xsrf-attacks]]
- [[3-2_json-hijacking]]
- [[3-3_xss_defend]]
- [[3-4_xsrf_defend]]

---

#### From [[_security]]

[//begin]: # "Autogenerated link references for markdown compatibility"
[3-1_xsrf-attacks]: 3-1_xsrf-attacks "3-1_xsrf-attacks"
[3-2_json-hijacking]: 3-2_json-hijacking "JSON Hi-Jacking"
[3-3_xss_defend]: 3-3_xss_defend "3-3_xss_defend"
[3-4_xsrf_defend]: 3-4_xsrf_defend "XSRF Defend"
[_security]: ../_security "7️⃣ Security"
[//end]: # "Autogenerated link references"
