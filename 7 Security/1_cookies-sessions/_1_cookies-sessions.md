# Cookies Sessions

## **7.1 Cookies, Sessions, and Session Theft**

Before we get into the thick of things, let’s quickly review the role of cookies in web
applications. If you recall, cookies are small pieces of data that browsers persist
between HTTP requests. This is a simple way of preserving state within an otherwise
stateless protocol (HTTP).
A web server sets a cookie by returning the Set-Cookie header in an HTTP
response. The contents of a cookie can be any string without spaces in it, but normally
it’s a set of key/value pairs. Consider the following example HTTP response, which
demonstrates setting a cookie named sessionid:

`HTTP/1.1 200 OK`  
`Date: Wed, 28 Sep 2011 14:33:37 GMT`  
`Content-type: application/json`  
`Set-cookie: sessionid=66d2520a77a3c6dac4db658c6dd13061`

Persisting user sessions is the primary use case of cookies in web applications. In this situation, when a user logs in, the server generates a unique token that identifies a user’s session with the web service, and stores it as a cookie on their browser. Then, when the user makes any subsequent HTTP requests to that server, the browser automatically sends the stored sessionid cookie to the server as part of the request’s.

**Cookie HTTP header:**

`GET /products/1337.json HTTP/1.1`  
`Host: camerastork.com`  
`Accept: application/json`  
`Cookie: sessionid=66d2520a77a3c6dac4db658c6dd13061`

When the server receives a request containing this cookie, it looks up the local user record that matches the passed session token. If a user is found, the server treats that user as the requesting party and returns content as appropriate. This continues until the cookie becomes expired or is deleted—either by the user or by the server in a subsequent Set-Cookie header.

The main issue with browser sessions is that they’re represented by a single value— a session token—stored in a cookie. If an attacker can ever gain access to that session token, they can easily authenticate with the affected web service as that user. Afterward, the attacker can perform any number of actions with that user’s identity, like access or manipulate their private data. Obviously, this is a disastrous scenario, but short of physically stealing a user’s computer, how does an attacker gain access to a user’s cookies?

In chapter 6, we introduced a scenario in which cookies can be stolen or hijacked by a malicious party: using a man-in-the-middle attack (MITM). This attack takes advan- tage of the fact that normal HTTP requests transfer data in plain text, such that cookies are vulnerable to packet sniffing. That means that on an unencrypted network (like your neighborhood coffee joint’s free Wi-Fi network), a malicious party can scan network traffic for HTTP requests containing session cookies and copy them.

In that chapter, we also told you that the best defense against MITM attacks is to use HTTP Secure (HTTPS) to encrypt all HTTP requests between the server and the browser. Because the HTTP requests are encrypted, they’re no longer vulnerable to packet sniffing, which all but eliminates the MITM threat.1

Though HTTPS is greatly encouraged, and a strong defense against MITM attacks, it’s not a panacea for all web application security threats. MITM is just one vector through which an attacker can gain access to a user’s cookies. Unfortunately, there are many other vulnerabilities that your web application needs to address before you can give it the rubber stamp of security approval. But don’t reach for the ejector seat but- ton just yet—we’ll guide you through these vulnerabilities in depth, and present solu- tions and defensive techniques as we go.

To kick things off, we’ll dive into perhaps the most common vulnerability affecting
JavaScript applications today: cross-site scripting.

## **Sub-chapters**

---

#### From [[_security]]

[//begin]: # "Autogenerated link references for markdown compatibility"
[_security]: ../_security "7️⃣ Security"
[//end]: # "Autogenerated link references"
