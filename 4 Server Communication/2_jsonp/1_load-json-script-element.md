# Load JSON Script Element

## **4.2.1 Loading JSON via script elements**

As you’ve learned, the same-origin policy has a significant exception: HTML script
elements are waived from SOP checks. That means that your third-party application
code is free to make HTTP requests to other origins by loading external JavaScript
files. JSONP leverages this exception to load data from a different domain.

To understand how JSONP works, let’s first look at an example of retrieving a regu-
lar, ordinary JSON document using XmlHttpRequest. Suppose you’re making an

XmlHttpRequest to http://thirdpartyjs.com/info.json, which returns a JSON docu-
ment containing critical information about the book you’re currently reading:

{
"title": "Third-party JavaScript",
"authors": ["Anton", "Ben"],
"publisher": "Manning"
}

The browser receives this response as a string. In order to be useful, it has to be con-
verted to a JavaScript object. This can be done using the browser’s native JSON.parse

function, or some other JSON library method when the native JSON object is unavail-
able (older browsers).

Of course, XMLHttpRequest only works across the same domain because of the
same-origin policy. But as we mentioned earlier, you can request this same URL using a

<script> element, which is immune to the SOP:
<script src="http://thirdpartyjs.com/info.json"></script>

By requesting this resource via a <script> element, the browser will evaluate the JSON
response as JavaScript immediately after the file is loaded. Then you’re free to use the
response data as you please, right? Not quite.
First, although this response is valid JSON and looks an awful lot like a normal

JavaScript object, it’s actually not valid JavaScript. When the browser attempts to evalu-
ate the response as JavaScript, it’ll fail with a syntax error. This is because JavaScript

interpreters parse the opening curly brace as the beginning of a block statement, and
expect it to be followed by one or more valid JavaScript statements.

But suppose that this response is a valid JavaScript object, and the object is evalu-
ated by the browser without error. Because the object isn’t stored, either by being

assigned to a variable or passed as a parameter to a function, the browser will discard
it. There’s no way to capture the actual response body during any step of the script
element’s loading process, so there’s no alternate way of capturing the JSON payload.
CAPTURING JSON OUTPUT
But what if instead of returning a naked JSON object, the server returned a JavaScript
statement that somehow stored this object? For example, what if an alternate URL,
http://thirdpartyjs.com/info.js (different file extension—.js instead of .json),
returned the following:
var jsonResponse = {
'title': 'Third-party JavaScript',
'authors': ['Anton', 'Ben'],
'publisher': 'Manning'
};

Now the JSON object can be accessed after the file has been loaded via the global vari-
able jsonResponse. You can use the <script> element’s load event to notify your

code when the variable contains the requested data.
An alternate approach is to pass the JSON object via a callback function instead of
a global variable:
jsonHandler({
'title': 'Third-party JavaScript',
'authors': ['Anton', 'Ben'],
'publisher': 'Manning'
});
The nice thing about using a callback function to capture the output is that you no
longer have to rely on the <script> element’s load event in order to know when the JSON object is available. Instead, the callback is executed the moment info.js is evalu-
ated. This requires that the callback function (jsonHandler) is already defined by

your application in the global context before the <script> element is loaded.

---

### From [[_2_jsonp]]

[//begin]: # "Autogenerated link references for markdown compatibility"
[_2_jsonp]: _2_jsonp "JSONP"
[//end]: # "Autogenerated link references"
