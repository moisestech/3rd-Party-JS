# Security Limit Concerns

## **4.2.3 Limitations and security concerns**

JSONP is a fairly simple technique and, armed with the examples from section 4.2,
you have everything you need to use it. Although it can be powerful, it’s not a silver

bullet for all of your cross-domain needs. The trick that makes it so easy and so pow-
erful (<script> element injection) is also responsible for all its limitations and secu-
rity issues.

First and foremost, JSONP only works with GET HTTP requests. Just as you can’t
load JavaScript files using POST, PUT, or DELETE request methods, the same goes for
JSONP. Being restricted to GET requests means a number of limitations. For starters,
the amount of data you can submit to the server is limited to the browser’s maximum
URL size (only 2,083 characters in Internet Explorer; see http://support.microsoft
.com/kb/208427). Additionally, you can’t use multipart forms for uploading files. It
can also make it difficult to work with REST-based APIs that use different HTTP request
methods to identify API calls. If you’re implementing such an API, you’ll likely have to
implement special GET-only endpoints that work with your JSONP requests.

Additionally, JSONP lacks error handling. If the script is successfully injected, your
callback gets called, but if not, nothing happens. This means you can’t detect cases
where a JSONP request has finished with a 404, 500, or any other server error. The best
you can do is assume the request failed after a given timeout has passed without a
response (say, 10 seconds) and initiate your own error callback.

DON’T USE JSONP WITH UNTRUSTED PARTIES You have to be careful when add-
ing support for JSONP because naive implementations can open serious secu-
rity vulnerabilities. Loading script tags from remote sites allows them to inject

any content into a website, so you’re implicitly trusting the other party. You

shouldn’t use JSONP to communicate with a third party unless you have com-
plete trust in that party.

On the security front, JSONP opens up the possibility of cross-site request forgery (CSRF)
attacks. A CSRF attack happens when a malicious site causes a visitor’s browser to make
a request to your server that causes a change on the server. The server thinks, because
the request comes with the user’s cookies, that the user wanted to submit that form or

make that request. With CSRF attacks, a malicious party can change the victim’s prefer-
ences on your site, publish inappropriate or private data, transfer funds to another

account (in the case of a bank’s web interface), and so on. And the only thing an
attacker needs to do, in the case of JSONP, is change the response from a valid callback
to any other JavaScript code! We’ll cover CSRF attacks and other security issues in
chapter 7.
AN ATTEMPT TO DEFINE A SAFER VERSION OF JSONP Because of all the security

issues associated with JSONP, there are attempts to either replace this tech-
nique with a less hacky alternative or to fix the current approach. One such

attempt is published on json-p.org and is based on the idea of defining
a safer, stricter version of JSONP. Its intention is that only a function reference
can be used for the padding of the JSONP response (defined by the

application/json-p MIME type) and nothing else. That approach could poten-
tially solve the “arbitrary JavaScript” problem, but it relies on the assumption

that all browsers enforce that rule. Unfortunately, we’re not aware of a single
browser that does.
Last, JSONP requests are always asynchronous. As soon as you attach a script element
to the DOM or submit a form, your browser will go on to the next task without waiting

for the response. This is unlike XmlHttpRequest, which traditionally operates asyn-
chronously, but can be forced to block the browser until the response is ready. Admit-
tedly, the odds of you requiring synchronous JSONP requests are low, but if you do,

you’re out of luck.
Despite these limitations, JSONP is still the third-party developer’s method of choice
for doing cross-domain communication. It’s easy, and it works. But there are times
when JSONP won’t cut it: namely, when you need to make POST or other HTTP requests.
Subdomain proxies, another browser workaround for making cross-domain requests, enable you to make any HTTP request you desire. The caveat is that they may only be
useful to a niche use case of third-party applications. Let’s find out more, shall we?

---

#### [[_2_jsonp]]

[//begin]: # "Autogenerated link references for markdown compatibility"
[_2_jsonp]: _2_jsonp "JSONP"
[//end]: # "Autogenerated link references"
