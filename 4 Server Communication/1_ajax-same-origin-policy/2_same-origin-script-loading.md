# Same Origin Script Loading

## **4.1.2 Same-origin policy and script loading**

Now, you’re probably thinking, “Wait a minute, didn’t we spend all of chapter 2 learn-
ing how to load an external JavaScript file (located at camerastork.com) on the
publisher’s website (publisher.com)? Wouldn’t that be considered an HTTP request

between two different origins, and should thus be rejected according to the same-
origin policy?”

The same-origin policy happens to have a single, crucial exception: HTML script
elements are waived from SOP checks. This waiver is crucial to the modern web because it
allows websites to load JavaScript files from other origins. This has a number of uses,
like allowing websites to load JavaScript resources from high-performance content
delivery networks (CDNs). It also gives you, as a third-party JavaScript application
developer, a way to distribute your application code. Without it, publishers wouldn’t
be able to include your script files, and we wouldn’t have much of a book to write.

It’s also important to recognize that even though your code is loaded from a differ-
ent origin, your code executes in the context of the publisher’s website—and is subject

to the SOP constraints placed on that document. That means that your JavaScript

code (executing in the context of the publisher’s page) can’t initiate an XmlHttp-
Request to camerastork.com (see figure 4.2). But it could load more JavaScript files,

since we’ve established that script elements are exempt from the SOP.
The same-origin policy is a terrific security feature, but it’s a real drag in cases
when you need to legitimately send data between domains, like accessing data from
the Camera Stork servers using XmlHttpRequest. It’d be nice if we—third-party

**Figure 4.2 Script element requests
are immune from the same-origin policy,
whereas XmlHttpRequests aren’t.**

JavaScript application developers—had access to a well-defined and secure method of
cross-domain communication. Fortunately, not so long ago, browser vendors saw the
demand and developed APIs that allow pages from different origins to communicate

with each other in a controlled manner. We’ll cover one of those methods—cross-
origin resource sharing (CORS)—in this chapter.1

But as is the case with most new browser features, they aren’t fully supported in all
browsers—and CORS is no exception. Because of this, you’ll need to defer to hacks
and workarounds. In the next couple of sections, we’ll go over two such workarounds

that allow you to bypass the same-origin policy: JSON with padding (JSONP) and sub-
domain proxies. Then, at the end of this chapter, we’ll go over CORS in depth,

because despite limited browser support, it’s the standardized, correct way to do cross-
domain communication.

---

#### From [[_1_ajax-same-origin-policy]]

[//begin]: # "Autogenerated link references for markdown compatibility"
[_1_ajax-same-origin-policy]: _1_ajax-same-origin-policy "AJAX Same Origin Policy"
[//end]: # "Autogenerated link references"
