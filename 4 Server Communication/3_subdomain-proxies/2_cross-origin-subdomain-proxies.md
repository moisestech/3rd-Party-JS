# Cross-origin Sub-domain Proxies

**4.3.2 Cross-origin messaging using subdomain proxies**

Let’s go back to our temporarily forgotten Camera Stork product widget. When we
left it, we were trying to request product data dynamically from the server in order to
render the product on the publisher’s page. Suppose the Camera Stork website has an
API endpoint located at http://camerastork.com/api/products that returns serialized

JSON data for a given product ID. Let’s write a function for your third-party applica-
tion that requests data from this URL. The function in listing 4.4 will use jQuery’s

AJAX helper function, jQuery.ajax, because you don’t want to write and maintain yet
another XmlHttpRequest library.

**Listing 4.4 A function to retrieve product information from the Camera Stork website**

function getProductData(id) {
jQuery.ajax({
type: "GET",
url: "http://camerastork.com/api/products/",
data: { product: id },
success: function (data) {
renderWidget(data);
}
});
}

As you’re probably well aware of by now, attempting this AJAX request from the pub-
lisher’s page to your own servers will fail miserably due to the same-origin policy. But

this can be circumvented using a subdomain proxy.
Let’s say your widget code is being executed on a publisher’s website located at
www.publisher.com. You’ve had them create a new subdomain, stork.publisher.com,

that points to your servers at camerastork.com. This means your product API end-
point will additionally be accessible at http://stork.publisher.com/api/products.

Now, even though this endpoint is available in the same domain space as the pub-
lisher’s page, your third-party script still can’t make direct AJAX requests to it. Because

both parties have to opt in to the same domain namespace, browsers must be able to
check for the origin value before making the request. And with AJAX it’s impossible to
check whether the receiving party wants to opt in without first making the request.
This is why, when it comes to XMLHttpRequest calls, browsers perform the SOP test
based on the request URL without initiating the actual request (as you’ll see later,
CORS specification fixes that issue by defining special headers and preflight requests).
SUBDOMAIN TUNNEL FILE
To work around this, you’ll need to host a page available through your newly created

subdomain proxy (stork.publisher.com) that will do two things: opt in to the pub-
lisher’s higher-level domain (publisher.com) and load the jQuery library:

<!DOCTYPE html>
<html>
<script>
document.domain = 'publisher.com';
</script>
<script src="jquery.min.js"></script>
</html>

If loading the jQuery library hasn’t already tipped you off, this is the page from which
you’ll actually make the AJAX request. It’s served from the same subdomain as the
(proxied) target API endpoint, so it can make AJAX requests to that endpoint without
restriction. But to be of any use, you’ll need to somehow access the page from your
widget code. The answer: iframes. If the publisher’s page also opts in to the higher
level domain, it can load a copy of this page in a hidden iframe, access the document’s
properties, and initiate the request. We like to call this intermediate document the
tunnel file (see figure 4.5).

Don’t worry, this is less work than it sounds. First, the publisher will need any pages
hosted on www.publisher.com that are loading your widget to opt in to their own
higher-level domain (publisher.com). You could do this from your widget code, but
it’s better if changes to document.domain are done at the top of the page’s HTML
source, in the <head> element:

<!DOCTYPE html>
<html>
<head>
<script>document.domain = 'publisher.com';</script>
...

Yes, your third-party script could set document.domain itself, but, as we mentioned ear-
lier, it’s better to set the document.domain as early in the page load as possible. Setting

the origin too late can result in a lot of undefined and buggy behavior and is best
avoided.

Next up, initiating the request. The code in listing 4.5 amends the getProduct-
Data function to load the proxy page into a hidden iframe and grabs a handle to the

jQuery.ajax method from a reference to the proxy’s global window object. This
object is accessible from the parent window via the special contentWindow property.

**Listing 4.5 Loading the tunnel file and grabbing a handle to jQuery.ajax**

You can now relax and enjoy the ability to communicate with your servers from your

third-party script executing on a publisher’s page. This particular implementation cre-
ates a new iframe for each call to getProductData, but that’s easily remedied by pre-
serving the iframe object between calls.

---

#### From [[_3_subdomain-proxies]]

[//begin]: # "Autogenerated link references for markdown compatibility"
[_3_subdomain-proxies]: _3_subdomain-proxies "Subdomain Proxies"
[//end]: # "Autogenerated link references"
