# Sub-domain JSONP Proxies

## **4.3.3 Combining subdomain proxies with JSONP**

Besides the obvious downside of subdomain proxies (requiring publishers to config-
ure a dedicated subdomain), there’s another subtle downside to this implementation:

it requires loading an intermediary tunnel file before it can make cross-domain
requests. For most applications, that’s not a big deal. But it’s worth pointing out that

there’s a variation of the subdomain proxy technique that doesn’t require any inter-
mediary pages, one that uses some JSONP concepts you learned in section 4.2.

This technique works by using <form> HTML elements instead of XmlHttpRequest.
When forms are submitted to a target URL, they pass any child input parameters to
the server, and the response is loaded in the current browser window. You can use
JavaScript to both dynamically generate these forms and submit them. The following
listing shows an example of generating and submitting a form using POST to submit a
Camera Stork product review to the server.

**Listing 4.6 Creating and submitting an HTML form via JavaScript**

Generating and submitting a form with JavaScript is simple. You create a new form ele-
ment, attach hidden input elements with necessary form parameters, and then submit

the resulting form. After submitting, you just need to clean up after yourself by delet-
ing the form element from the DOM tree.

SETTING THE NAME ATTRIBUTE IN INTERNET EXPLORER 7 AND EARLIER You might
have noticed that we set the name attribute to our input elements in listing
4.6. Unfortunately, legacy versions of the Internet Explorer browser prohibit

setting that attribute on elements dynamically created with the create-
Element method. To get around this limitation, you’ll have to use a special,

Microsoft-only form of the createElement call:
var input = document.createElement('<input name="score"/>');

**Figure 4.6 Submitting the form as-is causes the form response to load in the
parent window. Because this redirects away from the publisher’s page, this
behavior is undesirable.**

There’s one critical problem. If you try running this code, you’ll notice that the page
has been reloaded, and now points at the URL in the form action (see figure 4.6). This
is normal behavior when submitting HTML forms, but normal isn’t what we’re after;
we want to submit the form without changing the browser’s URL.
IFRAME-TARGETING FORMS

Fortunately, forms in HTML have a special attribute named target that you can use to
cause your form to load its response in a specific window object—including iframes.
When the response is loaded in the iframe, the current page URL is left as-is. So, as
you may have already guessed, you’ll need to modify your code to first create a hidden
iframe and have the created form target it.

**Listing 4.7 HTML form submitted into a hidden iframe**

Now the code will submit your form into an iframe without reloading the host page
(see figure 4.7).
Although the ability to secretly make cross-domain POST requests is terrific, this
doesn’t actually do anything with the response from the server. To accomplish that,
you’ll need to mix your current approach with a helping of JSONP. To make tunneling

work, the server must return an HTML page with JavaScript code that invokes the call-
back hosted in its parent window. This last part is important. Remember when we told

you that JSONP callbacks must be defined in the current execution context? With sub-
domain tunneling, this is no longer true, because callbacks for tunneled responses

must be defined in the parent’s execution context. This means that in order to call
the desired function, you’ll have to go one level up the window tree. And since you’ll
be accessing objects outside of the iframe’s scope, both parties (your iframe and its
host window) must change their origins to the common domain suffix:

```html
<!DOCTYPE html>
<html>
  <script>
    document.domain = "publisher.com";
    window.parent.jsonpCallback('{"status":"success"}');
  </script>
</html>
```

As you can see, the difference between JSONP and this method is just in the padding.
Normal JSONP uses a simple function call as its padding, whereas this technique uses
an entire HTML document. But note that the actual response data—the JSON object—
didn’t change. A good API always provides different endpoints that present the same
data in different formats.

---

#### From [[_3_subdomain-proxies]]

[//begin]: # "Autogenerated link references for markdown compatibility"
[_3_subdomain-proxies]: _3_subdomain-proxies "Subdomain Proxies"
[//end]: # "Autogenerated link references"
