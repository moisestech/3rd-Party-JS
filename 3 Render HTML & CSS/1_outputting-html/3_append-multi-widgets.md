# Append Multi Widgets

## 3.1.3 Appending Multiple Widgets

If you intend to support multiple instances of your widget on one page, you should

avoid using IDs to identify your script include snippet, and instead use data-_ attri-
butes. You can alternatively use classes, but data-_ attributes have additional advan-
tages we’ll cover later in this section.

Listing 3.2 shows the Camera Stork script include from earlier, this time identified
by the data-stork-widget custom attribute instead of an ID. You’ll note that the
data-stork-widget doesn’t have a value—don’t worry, it’s still valid HTML.

**Listing 3.2 The Script include snippet again, now identified with a data-\* atrribute**

<script data-stork-widget>
(function() {
var script = document.createElement('script');
script.async = true;
script.src = 'http://camerastork.com/widget.js?product=1234';
var entry = document.getElementsByTagName('script')[0];
entry.parentNode.insertBefore(script, entry);
})();
</script>

This version makes it possible to query multiple instances of your script include snip-
pet in the case where the publisher has added it multiple times. The downside is that

querying the DOM for data-_ attributes is slower than fetching elements by ID.
Here’s an example function that uses jQuery to insert HTML before a script
include snippet that identifies itself using the data-_ attribute shown previously.
jQuery, as always, makes this remarkably easy:
function appendWidgetMarkup(html) {
jQuery('script[data-stork-widget]').first()
.removeAttr('data-stork-widget')
.before(html);
}

This helper function locates the first script element with the data-stork-widget attri-
bute and inserts the markup before it. It then removes the data-stork-widget attri-
bute so that it isn’t selected again by any subsequent executions of your code. That

way, if a publisher includes a second instance of your script include snippet, the code

loaded by that snippet won’t accidentally output HTML at the first script include snip-
pet’s location.

PREVENTING RACE CONDITIONS
This opens up a potential race condition. Consider the case where a publisher wants

to include two Camera widgets on their web page, one each for two different prod-
ucts. To do this, they’re including two separate instances of your script include snip-
pet, each of which passes a different product ID to the application code. If the second

snippet is somehow loaded and exe-
cuted by the browser before the first,

which is possible since they’re being

loaded asynchronously, when the appli-
cation attempts to output HTML to the

page, it’ll query for elements with the
data-stork-widget attribute and get
the first script include snippet instead of
the second. When the dust settles, this

will result in each product widget get-
ting rendered in the opposite order,

and thus at the opposite location (see
figure 3.1).

To remedy this, the data-stork-
widget attribute should additionally

identify the target product that is to be
rendered. That way you can ensure only
the matching product is rendered at

that location. This would turn the exam-
ple script include into the following:

<script data-stork-product="1337">
...
</script>

Afterward, instead of querying for an arbitrary element with the data-stork-
product attribute, you’ll look for the element that contains the product ID you’re

trying to render:
function appendWidgetMarkup(id, html) {
jQuery('script[data-stork-product="' + id + '"]')
.removeAttr('data-stork-product')
.before(html);
}
It’s still a good idea to remove the data-stork-product attribute afterward, because
it’s still possible that a publisher could include two script include snippets referencing
the same product ID. If the attribute isn’t removed, both products will be rendered at
the same location.

---

### From [[_1_outputting-html]]

[//begin]: # "Autogenerated link references for markdown compatibility"
[_1_outputting-html]: _1_outputting-html "Outputting HTML"
[//end]: # "Autogenerated link references"
