# Optimizing JS

## **9.2 Optimizing Javascript**

The first part of this chapter focused on optimizing your application in terms of pay-
load: reducing the number of HTTP requests generated by your browser, minimizing

the amount of data transferred, and deferring non-essential requests. Now we’ll opti-
mize the JavaScript code you’re actually transferring to users’ browsers.

You might be wondering, with all the recent developments in JavaScript engines,
should you really care about code performance, or do modern engines take care of
performance issues for you? It’s true that modern engines have become much faster,
but even with all the recent speed improvements, it’s still possible to write slow
JavaScript applications—and slowness caused by a naively written piece of JavaScript
code can affect end-user experience more than an unoptimized payload. Poor
JavaScript performance can do more than just impact the user’s experience with your
application—it can also impact the user’s experience with the publisher’s page, which is
something you absolutely can’t afford.
Though this section is by no means an exhaustive lesson in all things JavaScript
optimization, we’ll introduce you to a number of performance concepts that we feel
are critical to developing third-party applications. We’ll teach you about the browser’s
UI thread and two internal browser events, repaint and reflow, whose behaviors are
crucial to know if you’re serious about high-performance JavaScript. We’ll also show
you how to wrap expensive calls with throttle and debounce, two helpful functions

that limit how often your code is executed. Last, we’ll look at a technique for minimiz-
ing the impact of long computations using the setTimeout function. Let’s start by dig-
ging into the browser and learning how it works from the inside.ww

## **Sub-chapters**

---

#### From [[_performance]]

[//begin]: # "Autogenerated link references for markdown compatibility"
[_performance]: ../_performance "9️⃣ Performance"
[//end]: # "Autogenerated link references"
