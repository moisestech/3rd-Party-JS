# Render Before doc

## **9.3.2 Rendering before document ready**

In modern JavaScript development, it’s common to write code that waits until the doc-
ument has finished processing before rendering anything to the page. Otherwise, you

risk running code that queries an incomplete DOM, and in some browsers, even risk
crashing the browser.2

To hammer this point home, nearly every popular JavaScript
library offers a DOM ready event handler. For example, jQuery offers the following
helper method for executing code only after the DOM has been fully parsed by the
browser:
$(document).ready(function() {
// Can safely modify DOM here
});

This is a safe, encouraged practice of web development. But for a third-party applica-
tion developer, sometimes the DOM ready event doesn’t happen fast enough. If you

wait for it to occur before rendering to the page, you’ll be executing at the same
time—or even after—other JavaScript applications being run by the publisher. If some
of those applications are slow, or your code ends up last in the UI thread queue and
renders after all others, your application may appear to users as having loaded slowly,
even if your JavaScript code and other resources were ready to go.
But how do you safely render to the page if the document isn’t ready? There’s one
way: by inserting either before or into a known, closed element that has already been
processed by the browser. Ideally this element is defined by publishers before your
script include snippet—that way, it’s guaranteed to exist in the DOM before your script
even executes.
You should never boldly assume that this element is always available. There’s always

the possibility that it’s added incorrectly by the publisher after the script include snip-
pet, or even at the bottom of their HTML source. In that case, you’ll have to fall back

to waiting for the document ready event. A utility function for determining when the
document is safe to manipulate is shown next.

**Listing 9.7 Calling a function when the DOM is ready, but before the onload event**

function onDOMReady(callback) {
var isReady = false;
if (window.addEventListener) {
window.addEventListener('DOMContentLoaded', callback, false);
return;
}

window.attachEvent('onload', function () {
isReady = true;
callback();
});
var timer = setInterval(function () {
if (isReady) {
clearInterval(timer);
return;
}
if (document && document.getElementsByTagName &&
document.getElementById && document.body) {
clearInterval(timer);
callback();
return;
}
}, 20);
}

Note that Firefox, Opera, Chrome, and Safari support an event called DOMContent-
Loaded that fires when the document is ready. For those browsers that don’t support

this event, this function implements a series of fallback tests to determine when it’s
ready.
By skipping the document ready event as much as possible, you cut in line ahead

of most scripts and are often capable of rendering much sooner. This gives your appli-
cation the illusion of being faster, since you’ll (probably) never end up being the last

widget loading on the publisher’s page.

---

#### From [[2_render-before-doc]]

[//begin]: # "Autogenerated link references for markdown compatibility"
[2_render-before-doc]: 2_render-before-doc "Render Before doc"
[//end]: # "Autogenerated link references"