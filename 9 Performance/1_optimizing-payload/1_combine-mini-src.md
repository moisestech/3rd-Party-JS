# Combine Mini Src

## **9.1.1 Combining and minifying source code**

If your JavaScript application becomes reasonably large, it’s probably safe to assume
that your source code is spread out across several files (if it’s not, take a deep breath,
go for a walk, and think about your development practices). Although this is a good
idea from a development standpoint, by requiring the browser to download multiple
files, you’re potentially slowing down the performance of your application. This is
because for every resource requested by your application, the browser has to open a
network connection, send the request and all HTTP request headers, receive the file
and all response headers, and finally close the connection. This overhead quickly adds
up for multiple files.

To avoid this overhead, it’s common practice to define a build process that com-
bines files of the same type into single, larger files. Then, when your application is

deployed to a production environment, it’ll load these combined files instead of your
development files, reducing the number of HTTP requests. While you’re at it, your
build process should also minify your newly combined files, using JavaScript and CSS
minification tools. This can significantly reduce the file size of your combined files.
CODE MINIFICATION Code minification is the process of rewriting your source
code to be as small as possible, while also preserving its functionality. This is
done by removing nonfunctional whitespace and comments, and also by
rewriting variable and function names. Both your JavaScript and CSS code
can be minified.

The impact of code minification can be startling. For example, recent ver-
sions of the jQuery library weigh it at roughly 250 KB of code. When minified,

that number drops to around 92 KB—more than 63% smaller.
Today, we’re lucky to have some really good minification tools—such as Google Closure

Compiler, Yahoo YUI Compressor, UglifyJS, and others—that allow for such a build pro-
cess to be expressed in a short build file. Here’s a simple build file using the granddaddy

of all build utilities, Make, that’s available for all modern operating systems:
CLOSUREFILE=bin/closure-compiler.js
BUILDDIR=build
combine:
@cat myfile1.js myfile2.js > build.js
minify: combine
@java -jar $(CLOSUREFILE) --js_output_file=$(BUILDDIR)/build.js

Now, whenever your JavaScript application decides which files to load, it should check whether it’s running in a development or production environment. If it’s a develop-
ment environment, your application should load your original source code files. If it’s

a production environment, your application should load the combined and minified
file produced by your build script:

```javascript
if (Stork.debug) {
  loadScript("http://camerastork.dev/widget/myfile1.js");
  loadScript("http://camerastork.dev/widget/myfile2.js");
} else {
  loadScript("http://cdn.camerastork.com/12345/build/build.js");
}
```

**COMBINING ASSETS IN IFRAMES**
Don’t forget that any iframed documents loaded by your application represent addi-
tional HTTP requests, and that the browser must also load any resources referenced

inside the iframe. So when you combine and minify files, don’t forget about compo-
nents that are used inside of iframes.

If you’re feeling bold, it’s possible to reduce an entire HTML page to a single HTTP
request. This is done by inlining JavaScript and CSS directly into the page’s HTML
source code. This is a step you can incorporate into your project’s build process:

```html
<!DOCTYPE html>
<html>
  {% if dev %}
  <script src="channel-requirements.js"></script>
  {% else %}
  <script>
    {% include channel-requirements.js %}
  </script>
  {% endif %}
</html>
```

---

#### From [[_1_optimizing-payload]]

[//begin]: # "Autogenerated link references for markdown compatibility"
[_1_optimizing-payload]: _1_optimizing-payload "Optimizing Payload"
[//end]: # "Autogenerated link references"
