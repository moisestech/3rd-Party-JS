# Caching Files

## **9.1.3 Caching Files**

So far, we’ve been assuming that the browser loads resources as if it has just seen them
for the first time. But as you probably already know, this is simply not true. Browsers
use a cache to reduce the number of HTTP requests and decrease the size of HTTP

responses, making your application load faster. You can help the browser out by speci-
fying Expires and Cache-Control headers in your HTTP responses, which tell the

browser for how long it’s safe to use the cached copy of a resource. For example, this is
a far-future Expires header that tells the browser that the file won’t be updated until
November 10, 2018:1
Expires: Sun, 10 Nov 2018 18:00:00 GMT
But it’s really hard to guess what’s an optimal expiration time for a static component
of your application. Make it too short, and you don’t use the cache to its fullest. Make

it too long, and you have problems with users getting older versions of your resources
when you really want them to have the latest.
One way to solve this problem is to set a far-future Expires header (tell the
browser that this copy is good for, let’s say, one year) and at the same time insert a
unique version string into your resource’s URL. When you want to force users to fetch
a new copy, you’ll modify the version string. To see this in action, let’s borrow a code

snippet from chapter 2 that loads required JavaScript files for the Camera Stork wid-
get. We’ll modify this snippet to use versioned URLs instead:

loadScript('http://cdn.camerastork.com/' + version + '/build/dom.js',
function() {
// use DOM library
}
);
You’ll notice the version string comes immediately after the domain part of the
requested file’s URL. In order to force browsers to ignore their cache and download
the latest version of the file, all you need to do is change this version string. This is
because the new version resides at a different URL, which means browsers will treat
the file as an entirely new, unknown resource.
In order for this approach to work, your scripts need to obtain the current version
from somewhere. And this version string can’t be obtained through a similarly cached
resource; otherwise users will be faced with the same problem—they’ll never get an
updated version string and will never download the latest set of files. The best solution
is to include the version string with your initial loader code and ensure it’s not cached
by the browser (or not cached for long). This is another reason for your initial loader

script to be as small as possible: since it can’t be as aggressively cached, it’ll be down-
loaded far more often than your application’s other resources.

---

### From [[_1_optimizing-payload]]

[//begin]: # "Autogenerated link references for markdown compatibility"
[_1_optimizing-payload]: _1_optimizing-payload "Optimizing Payload"
[//end]: # "Autogenerated link references"